<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo主题添加目录]]></title>
    <url>%2F2017%2F04%2F20%2Fhexo-theme-toc%2F</url>
    <content type="text"><![CDATA[自从使用Hexo建博客以来,前后体验过好几种主题，其中 Litten 的 Yilia, 简洁优雅,十分喜欢. 在此表示感谢!!Yilia 主题目前还没有添加toc目录功能,长篇幅文章有目录会显得层次清晰,所以简单的实现并记录之! 修改hexo主题的ejs文件编辑文章显示页面的模板编辑 themes/yilia/layout/_partial/article.ejs文件。在该文件中&lt;%- post.content %&gt; 之前加入如下代码： 12345678910111213141516&lt;% &#125; else &#123; %&gt; &lt;!--Table of Contents begin--&gt; &lt;% if ( post.toc || ( theme.toc &amp;&amp; post.toc !== false) &amp;&amp; !index)&#123; %&gt; &lt;div id="toc" class="toc-article"&gt; &lt;strong class="toc-title"&gt;目录&lt;/strong&gt; &lt;a class="js-toggle-toc" href="javascript:void(0)"&gt;&lt;/a&gt; &lt;div class="toc-content"&gt; &lt;%- toc(post.content) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;!--Table of Contents end --&gt; &lt;%- post.content %&gt;&lt;% &#125; %&gt; 如果生成的目录不需要前面的编号，将 &lt;%- toc(post.content) %&gt;修改为 &lt;%- toc(post.content, {list_number: false}) %&gt; 开启目录1. 默认开启：主题配置文件 themes/yilia/_config.yml 下 toc: true , 默认开启全局目录生成,在不需要生成目录的单篇文章开头 front-matter 添加 toc: false 2. 默认不开启： 如果主题配置文件中 toc: false , 则在需要生成目录的文章开头添加 toc: true 1234---title: Hexo主题添加目录toc: true--- TOC默认的样式 为目录编写CSS在themes/yilia/source-src/css/ 下新建 toc.scss, 在文件的最后，添加如下样式,并在 main.scss 中引入 @import &quot;./toc&quot;; 123456789101112131415161718192021222324252627282930313233/*toc begin*/.toc-article &#123; background: #eee; margin: 0 0 0 0.2em; padding: 1em; -webkit-border-radius: 5px; border-radius: 5px; line-height: 1.5em; font-size: 1em; float: right; max-width: 32%; min-width: 200px; border: 1px solid #C0C0C0; white-space: nowrap; overflow: hidden; strong &#123; padding: 0.3em 0; &#125; ol, li &#123; margin: 0 0 0 0.2em; list-style-type: none; &#125; ol li:before &#123; display: none; &#125; /*下级目录的缩进量 */ .toc-child &#123; margin-left: 0.8em; &#125;&#125;/* toc end*/ 目录效果预览: 为目录编写js为目录编写js文件实现目录展开和折叠效果在themes/yilia/source-src/js/ 下新建 toc.js, 添加代码如下 123456789101112131415161718192021//需要jQuery支持function init() &#123; $(".js-toggle-toc").css('color', '#FF4081'); $(".js-toggle-toc").text("丨☆丨 收起 Ⅴ"); $(".js-toggle-toc").click(function()&#123; var toc = $(".toc-content"); toc.toggle(); if (toc.is(":hidden")) &#123; $(this).text("丨★丨 展开 》》"); &#125; else &#123; $(this).text("丨☆丨 收起 Ⅴ"); &#125; return false; &#125;); &#125; module.exports = &#123; init : init &#125; 并在 main.js 中加载 toc.js 12345// 目录import Toc from './toc'addLoadEvent(function() &#123; Toc.init()&#125;) 目录展开收起效果: 总结只是实现了基本目录功能,并添加了简单的样式，可以根据个人需求进一步修改和美化. ☆end☆]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
        <tag>hexo-theme</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小林家的两小只]]></title>
    <url>%2F2017%2F04%2F17%2Ffirst-essay%2F</url>
    <content type="text"><![CDATA[小林家的两小只 0.O! ☆END☆]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 tomcat的安装及开机自启动配置]]></title>
    <url>%2F2017%2F04%2F12%2Fcentos7-tomcat-autostart%2F</url>
    <content type="text"><![CDATA[安装tomcat tomcat是免安装软件,下载tomcat8.x.xx.tar.gz,使用sftp或vsftp等上传到服务器 通过tar命令直接解压到 /usr/local/ 目录下,为了方便操作,将其修改为tomcat8.sudo tar zxvf tomcat8.x.xx.tar.gz -C /usr/local/sudo mv tomcat8.x.xx tomcat8 配置开机运行 tomcat增加启动参数tomcat需要增加一个pid文件,在 _$tomcat_home/bin 目录下面，增加 setenv.sh 配置，catalina.sh_ 启动的时候会调用，同时配置java内存参数. 添加如下命令：[root@desnbo bin]# vi setenv.sh1234567891011121314#tomcat startup pid#set java runtime environment variable export JAVA_HOME=/usr/java/jdk1.8.0_121export PATH=$PATH:$JAVA_HOME/binexport CATALINA_HOME=/usr/local/tomcat8export CATALINA_BASE=/usr/local/tomcat8#add tomcat pidCATALINA_PID="$CATALINA_BASE/tomcat.pid"#add java optsJAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m" 注意: 配置开机运行时,需要再次添加 JAVA_HOME 增加 tomcat.service在/usr/lib/systemd/system目录下增加tomcat.service，目录必须是绝对目录,添加如下命令：[root@desnbo bin]# vim /usr/lib/systemd/system/tomcat.service 1234567891011121314151617# conf service desc ,set do this after network started[Unit]Description=tomcat After=syslog.target network.target remote-fs.target nss-lookup.target# conf service pid, start,stop and restart[Service]Type=forkingPIDFile=/usr/local/tomcat8/tomcat.pidExecStart=/usr/local/tomcat8/bin/startup.shExecStop=/bin/kill -s QUIT $MAINPIDExecReload=/bin/kill -s HUP $MAINPIDPrivateTmp=true# conf user [Install]WantedBy=multi-user.target [unit]: 配置了服务的描述，规定了在network启动之后执行， [service]: 配置服务的pid，服务的启动，停止，重启 [install]: 配置了使用用户 使用tomcat.servicecentos7使用systemctl替换了service命令,如需设置其他服务,替换此处的tomcat即可,如:systemctl start vsftp.service 启动服务systemctl start tomcat.service 停止服务systemctl stop tomcat.service 重启服务systemctl restart tomcat.service 增加开机启动systemctl enable tomcat.service 删除开机启动systemctl disable tomcat.service 因为配置pid，在启动的时候会在tomcat的根目录下生产tomcat.pid文件,服务停止后删除.同时tomcat在启动时，执行start不会启动两个tomcat，保证始终只有一个tomcat服务在运行.多个tomcat可以配置在多个目录下，互不影响。 查看效果重启服务器后,通过wget访问,终端输出如下所示,配置tomcat开机自启动成功! 123456789[desnbo@desnbo ~]$ sudo wget 192.168.1.200:8080--2017-04-12 03:09:09-- http://192.168.1.200:8080/Connecting to 192.168.1.200:8080... connected.HTTP request sent, awaiting response... 200 OKLength: unspecified [text/html]Saving to: ‘index.html.3’ [ &lt;=&gt; ] 11,230 --.-K/s in 0s2017-04-12 03:09:09 (158 MB/s) - ‘index.html.3’ saved [11230] 同时,客户端浏览器也能成功访问: ☆end☆]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>tomcat</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合Quartz作业调度框架]]></title>
    <url>%2F2017%2F03%2F29%2Fspring-quartz%2F</url>
    <content type="text"><![CDATA[Quartz 简介Quartz: 是一个完全由java编写的开源作业调度框架。是OpenSymphony开源组织在Job scheduling领域又一个开源项目，它可以与J2EE与J2SE应用程序相结合也可以单独使用。Quartz可以用来创建或简单或复杂的程序。Jobs可以做成标准的Java组件或 EJBs。 简单地创建一个实现org.quartz.Job接口的java类,实现Job接口包含的唯一方法：public void execute(JobExecutionContext context) throws JobExecutionException 在自己的Job接口实现类里面，添加一些逻辑到execute()方法。一旦你配置好Job实现类并设定好调度时间表，Quartz将密切注意剩余时间。当调度程序确定该是通知你的作业的时候，Quartz框架将调用你Job实现类（作业类）上的execute()方法并允许做它该做的事情。无需报告任何东西给调度器或调用任何特定的东西。仅仅执行任务和结束任务即可。如果配置你的作业在随后再次被调用，Quartz框架将在恰当的时间再次调用它. Spring整合 Quartz引入quartz.jar首先下载 quartz 1.6.1.jar,并加入到项目lib文件夹中;如果是使用Maven构建的项目,在pom.xml中添加如下依赖:123456&lt;!-- quartz --&gt;&lt;dependency&gt; &lt;groupId&gt;org.opensymphony.quartz&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;1.6.1&lt;/version&gt;&lt;/dependency&gt; 相关文件的配置新建调度工具类TimerTask.java12345678910111213package me.util.quartz;import me.util.format.FormatUtil;/** * Quartz定时器调度工具类 * @author Desnbo */public class TimerTask &#123; public void fnDemo() &#123; System.out.println("--- begin &gt;&gt;&gt;"); System.out.println("Quartz 定时器测试---" + FormatUtil.formatDateTime(System.currentTimeMillis())); System.out.println("--- end &lt;&lt;&lt;"); &#125;&#125; 配置applicationContext-quartz.xml123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd "&gt; &lt;!-- 1.将要控制的任务配置成Spring可以管理的对象(Bean) --&gt; &lt;bean id="timerTask" class="me.util.quartz.TimerTask"&gt; &lt;/bean&gt; &lt;!-- 2.定义作业业务 --&gt; &lt;bean id="jobTask" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;!-- 目标对象:指定对应的作业bean --&gt; &lt;property name="targetObject" ref="timerTask" /&gt; &lt;!-- 目标方法:指定对应的作业方法 --&gt; &lt;property name="targetMethod" value="fnDemo" /&gt; &lt;/bean&gt; &lt;!-- 3.配置具体的任务执行触发时间 --&gt; &lt;bean id="doTime" class="org.springframework.scheduling.quartz.CronTriggerBean"&gt; &lt;!-- 指定对应的任务 --&gt; &lt;property name="jobDetail" ref="jobTask" /&gt; &lt;!-- cron表达式指定对应的执行周期,此处为每30秒执行一次 --&gt; &lt;property name="cronExpression" value="0/30 * * * * ?" /&gt; &lt;/bean&gt; &lt;!-- 4. 总管理类:设置具体运行的定时任务,如果将lazy-init='false'那么容器启动就会执行调度程序 --&gt; &lt;bean id="startQuertz" class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;!-- 定义任务序列,list下可加入其他的调度器--&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="doTime" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 配置web.xml123456789&lt;!-- 设置Spring的监听，项目启动时候初始化 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- 指定Spring配置文件的路径,可使用通配符classpath:applicationContext*.xml--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-quartz.xml&lt;/param-value&gt;&lt;/context-param&gt; 启动服务器进行测试,控制台输出如下:123456789--- begin &gt;&gt;&gt;Quartz 定时器测试---2017-03-29 21:37:00--- end &lt;&lt;&lt;--- begin &gt;&gt;&gt;Quartz 定时器测试---2017-03-29 21:37:30--- end &lt;&lt;&lt;--- begin &gt;&gt;&gt;Quartz 定时器测试---2017-03-29 21:38:00--- end &lt;&lt;&lt; 测试成功! 使用时只需在配置文件中注入所需的属性,在相应的方法中添加需要执行的代码即可进行作业调度,实现如库存预警,定时发送邮件等功能. 关于cron表达式Cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6个或7个域，每一个域代表一个含义,Cron有如下两种语法格式： Seconds Minutes Hours DayofMonth Month DayofWeek Year Seconds Minutes Hours DayofMonth Month DayofWeek 每一个域可出现的字符如下：1234567Seconds:可出现,- * / 四个字符，有效范围为0-59的整数 Minutes:可出现,- * / 四个字符，有效范围为0-59的整数 Hours:可出现,- * / 四个字符，有效范围为0-23的整数 DayofMonth:可出现,- * / ? L W C八个字符，有效范围为0-31的整数 Month:可出现,- * / 四个字符，有效范围为1-12的整数或JAN-DEc DayofWeek:可出现,- * / ? L C #四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推 Year:可出现,- * / 四个字符，有效范围为1970-2099年 每一个域都使用数字，但还可以出现如下特殊字符，它们的含义是： *：表示匹配该域的任意值，假如在Minutes域使用*,即表示每分钟都会触发事件。 ?: 只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法: 13 13 15 20 * ?其中最后一位只能用？，而不能使用，如果使用表示不管星期几都会触发，实际上并不是这样。 -: 表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 /：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. ,: 表示列出枚举值值。例如:在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 L: 表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 W: 表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份 LW: 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。 #: 用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。 一个cron表达式有至少6个（也可能7个）有空格分隔的时间元素按顺序依次为:1234567秒（0~59） 分钟（0~59） 小时（0~23） 天（月）（0~31，但是你需要考虑你月的天数） 月（0~11） 天（星期）（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT） 年份（1970－2099） 其中每个元素可以是一个值(如6),一个连续区间(9-12),一个间隔时间(8-18/4)(/表示每隔4小时),一个列表(1,3,5),通配符。由于”月份中的日期”和”星期中的日期”这两个元素互斥的,必须要对其中一个设置?。 以下为一些cron表达式示例12345678910111213141516171819202122"0 0 2 1 * ? *" 表示在每月的1日的凌晨2点调度任务 "0 15 10 ? * MON-FRI" 表示周一到周五每天上午10：15执行作业 "0 15 10 ? 6L 2002-2006" 表示2002-2006年的每个月的最后一个星期五上午10:15执行作业 "0 0 10,14,16 * * ?" 每天上午10点，下午2点，4点 "0 0/30 9-17 * * ?" 朝九晚五工作时间内每半小时 "0 0 12 ? * WED" 表示每个星期三中午12点 "0 0 12 * * ?" 每天中午12点触发 "0 15 10 ? * *" 每天上午10:15触发 "0 15 10 * * ?" 每天上午10:15触发 "0 15 10 * * ? *" 每天上午10:15触发 "0 15 10 * * ? 2005" 2005年的每天上午10:15触发 "0 * 14 * * ?" 在每天下午2点到下午2:59期间的每1分钟触发 "0 0/5 14 * * ?" 在每天下午2点到下午2:55期间的每5分钟触发 "0 0/5 14,18 * * ?" 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 "0 0-5 14 * * ?" 在每天下午2点到下午2:05期间的每1分钟触发 "0 10,44 14 ? 3 WED" 每年三月的星期三的下午2:10和2:44触发 "0 15 10 ? * MON-FRI" 周一至周五的上午10:15触发 "0 15 10 15 * ?" 每月15日上午10:15触发 "0 15 10 L * ?" 每月最后一日的上午10:15触发 "0 15 10 ? * 6L" 每月的最后一个星期五上午10:15触发 "0 15 10 ? * 6L 2002-2005" 2002年至2005年的每月的最后一个星期五上午10:15触发 "0 15 10 ? * 6#3" 每月的第三个星期五上午10:15触发 有些子表达式能包含一些范围或列表子表达式（天（星期））可以为 “MON-FRI”，“MON，WED，FRI”，“MON-WED,SAT” * 字符代表所有可能的值, 因此 * 在子表达式（月）里表示每个月的含义，* 在子表达式（天（星期））表示星期的每一天 / 字符用来指定数值的增量, 例如：/ 在子表达式（分钟）里的“0/15”表示从第0分钟开始，每15分钟;/ 在子表达式（分钟）里的“3/20”表示从第3分钟开始，每20分钟（它和“3，23，43”）的含义一样. ? 字符仅被用于天（月）和天（星期）两个子表达式，表示不指定值 ,当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“？” L 字符仅被用于天（月）和天（星期）两个子表达式，它是单词“last”的缩写 ,但是它在两个子表达式里的含义是不同的。L 在天（月）子表达式中，“L”表示一个月的最后一天;L 在天（星期）自表达式中，“L”表示一个星期的最后一天，也就是SAT 如果在 L 前有具体的内容，它就具有其他的含义了,例如：6L 表示这个月的倒数第６天，FRIL表示这个月的最一个星期五.注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题 cron 表达式使用总结12345678字段 允许值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * ? / L W C 月份 1-12 或者 JAN-DEC , - * / 星期 1-7 或者 SUN-SAT , - * ? / L C # 年（可选） 留空, 1970-2099 , - * /]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery + ajax+ json + Struts2 实现表单联动]]></title>
    <url>%2F2017%2F03%2F18%2Fform-linkage%2F</url>
    <content type="text"><![CDATA[在进行信息添加的过程中，经常会用到上下联动的需求，如省市联动。商品的供应商和商品类别的联动。如何实现呢？ 预加载数据进入商品信息添加页面前，需要加载一些需要的数据 首先要加载所有的供应商信息集合与第一个供应商对应的商品类别集合，并进行展示; 当供应商信息发生变化时，ajax动态加载商品类别信息，并进行展示。 如果供应商的商品类别为空时，直接不加载1234567891011121314151617181920public GoodsModel gm = new GoodsModel();// 到添加public String input() &#123; // 加载所有具有类别信息的供应商信息 List&lt;SupplierModel&gt; supplierList = supplierEbi.getAllUnion(); ActionContext.getContext().getSession().put("supplierList", supplierList); // 加载当前选中的供应商对应的所有商品类别信息 Long supplierUuid = null; if (gm.getUuid() != null) &#123; // 修改操作 gm = goodsEbi.get(gm.getUuid()); supplierUuid = gm.getGtm().getSm().getUuid(); &#125; else &#123; //不是修改操作，默认加载第一个 supplierUuid = supplierList.get(0).getUuid(); &#125; List&lt;GoodsTypeModel&gt; gtmList = goodsTypeEbi.getAllBySupUuid(supplierUuid); ActionContext.getContext().getSession().put("gtmList", gtmList); return "input";&#125; 页面请求 为供应商select添加选项改变事件 123456$(function()&#123; //为id为supplier 绑定change事件 $("#supplier").change(function()&#123; &#125;);&#125;); 添加测试语句，测试功能是否正常，例如添加alert语句 在操作中发送ajax请求，获取后台数据 123$.post("goodsType_ajaxGetBySupUuid.action",&#123;"gm.sm.uuid":supplierUuid&#125;,function(data)&#123;&#125;); 其中的参数说明: 第一次参数：发送的请求url 第二个参数：json格式的参数列表 第三个参数：当前ajax异步请求执行完毕后返回的处理事件，其中data参数封装了后台请求传输的数据 后台处理数据 在产品类别GoodsTypeAction中添加对应的方法，根据传递供应商编号获取对应类别信息 12345678private List&lt;GoodsTypeModel&gt; gtmList;//ajax获取供应商对应的类别信息public String ajaxGetBySupUuid()&#123; //根据供应商的uuid获取对应的类别信息 gtmList = goodsTypeEbi.getAllBySm(gm.getSm().getUuid()); return "ajaxGetBySupUuid"; &#125; 如何将数据传递出去得到的数据需要转化为json格式,可以使用json工具类JSONArray,或使用struts-json插件。此处使用struts-json插件完成该功能(√) 加入相关jar包向项目中加入struts-json对应的jar包 struts-json-plugin.jar 提供get方法该插件只能将Action类中的get开头的方法数据返回，因此为上述方法对应的数据提供get方法123public List&lt;GoodsTypeModel&gt; getGtmList() &#123; return gtmList;&#125; 配置struts.xml struts.xml文件中开启json数据格式支持，修改默认的继承模式 &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;json-default&quot;&gt; 设置对应的结果返回类型为json数据格式类型 type=&quot;json&quot; 12345&lt;!-- GoodsType --&gt;&lt;action name="goodsType_*" class="goodsTypeAction" method="&#123;1&#125;"&gt; &lt;result name="ajaxGetBySupUuid" type="json"&gt; &lt;/result&gt;&lt;/action&gt; 设置数据来源设置返回json数据，并没有指定返回的数据来源，需要指定返回数据来源,有几种常见方式 设置数据来源于action类中:&lt;param name=&quot;root&quot;&gt;action&lt;/param&gt;如果只设置数据来源于action类中，那么此时返回的数据将是Action类中所有的get方法开头的方法返回值，一般需要过滤。 包含过滤设置: &lt;param name=&quot;includeProperties&quot;&gt;gtmList\[\d\]\.uuid,gtmList\[\d\]\.name&lt;/param&gt; 排除过滤设置: &lt;param name=&quot;excludeProperties&quot;&gt; gtmList\[\d\]\.sm, &lt;/param&gt; 设置数据来源从某个根获取: (√) 1234567&lt;result&gt; &lt;param name="root"&gt;action&lt;/param&gt; &lt;param name="includeProperties"&gt; gtmList\[\d\]\.uuid, gtmList\[\d\]\.name &lt;/param&gt; &lt;/result&gt; PS: 设置root时，还可以设置对象或者集合对象。如果是对象，则获取的数据为对象json格式转化;如果是集合对象，则获取的数据为集合中的对象数组.上述格式中设置了需要的数据位gtmList集合中每个元素的uuid属性与gtmList集合中每个元素的name属性。 页面获取json数据 请求相应的回调方法的参数data中封装了上述返回的json格式数据,根据json数据的格式特点，获取其中的gtmList数据 将获取的数据拼装成jquery格式的option组件，并添加到对应的select中 由于每次都向类别select中添加数据，数据越来越多，应该每次先清除掉原始数据，然后添加。 12345678910111213var supplierUuid = $(this).val();$.post("goodsType_ajaxGetBySupUuid.action",&#123;"gm.sm.uuid":supplierUuid&#125;,function(data)&#123; //清除当前select中的项 $("#goodsType").empty(); var gtmList=data.gtmList; for(var i = 0 ; i&lt;gtmList.length;i++)&#123; var gtm=gtmList[i]; //将获取的数据组织成select中的option选项,然后添加到select中 $op=$("&lt;option value='"+gtm.uuid+"'&gt;"+gtm.name+"&lt;/option&gt;"); //将选项添加到select中 $("#goodsType").append($op); &#125;&#125;); 效果展示 知识总结 jquery发送ajax请求的方式 struts-json-plugin插件的使用方式 收集数据时，产品数据只需收集其类别数据即可，无需收集对应的供应商编号，毕竟后台数据模型关系式产品与产品类别产生关系。 其他如省市联动等也可以用类似的实现方式，使用起来也是非常方便的。 ☆end★]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>json</tag>
        <tag>jQuery</tag>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text3 OmniMarkupPreviewer 404]]></title>
    <url>%2F2017%2F03%2F18%2FOmniMarkupPreviewer-404%2F</url>
    <content type="text"><![CDATA[什么是 Markdown Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。 OmniMarkupPreviewer : 作为 Sublime Text 的一款强大插件，支持将标记语言渲染为 HTML 并在浏览器上实时预览，同时支持导出 HTML 源码文件。 第一次使用时报了如下的错误: Browser123456Sorry, the requested URL 'http://127.0.0.1:51004/view/61' caused an error:'buffer_id(61) is not valid (closed or unsupported file format)'**NOTE:** If you run multiple instances of Sublime Text, you may want to adjustthe `server_port` option in order to get this plugin work again. SublimeText console log1234567891011121314151617181920212223242526272829303132333435SyntaxError: unexpected EOF while parsingOmniMarkupPreviewer: [INFO] Launching web browser for http://localhost:51004/view/42OmniMarkupPreviewer: [ERROR] Exception occured while rendering using MarkdownRenderer Traceback (most recent call last): File "~\Sublime Text 3\Packages\OmniMarkupPreviewer\OmniMarkupLib\RendererManager.py", line 266, in render_text rendered_text = renderer.render(text, filename=filename) File "~\Sublime Text 3\Packages\OmniMarkupPreviewer\OmniMarkupLib\Renderers/MarkdownRenderer.py", line 48, in render extensions=self.extensions) File "~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py", line 493, in markdown md = Markdown(*args, **kwargs) File "~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py", line 159, in __init__ configs=kwargs.get('extension_configs', &#123;&#125;)) File "~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py", line 185, in registerExtensions ext = self.build_extension(ext, configs.get(ext, &#123;&#125;)) File "~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py", line 291, in build_extension return module.makeExtension(**configs) File "~\Sublime Text 3\Packages\OmniMarkupPreviewer\OmniMarkupLib\Renderers\libs\mdx_strikeout.py", line 17, in makeExtension return StrikeoutExtension(configs=configs) File "~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\extensions\__init__.py", line 51, in __init__ self.setConfigs(kwargs) File "~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\extensions\__init__.py", line 82, in setConfigs self.setConfig(key, value) File "~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\extensions\__init__.py", line 70, in setConfig if isinstance(self.config[key][0], bool): KeyError: 'configs' 解决方案错误原因是默认扩展中的strikeout不能正常加载。 Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - User12345&#123; "renderer_options-MarkdownRenderer": &#123; "extensions": ["tables", "fenced_code", "codehilite"] &#125;&#125; 设置保存后就可以正常使用了. 结束语这虽然是一个小问题，但是由于还不熟悉Python，花了一些时间折腾，OmniMarkupPreviewer+ MarkdownEditing插件的结合，使用Sublime Text3 中进行markdown语法编辑和写作十分的方便,特此记录下来. ☆-end-☆]]></content>
      <categories>
        <category>SublimeText</category>
      </categories>
      <tags>
        <tag>SublimeText</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JQuery树状结构 jQuery Treeview 的使用]]></title>
    <url>%2F2017%2F03%2F17%2FjQuery-treeview-plugin%2F</url>
    <content type="text"><![CDATA[在项目中，我们经常会需要一些树状结构的样式来显示层级结构，菜单等，利用Jquery的一些插件，可以实现这些效果的，如Jquery.treeview。jquery treeview树控件是一款非常实用的jquery插件。 参数说明 参数说明参看 jQuery treeview 插件参数说明 其中 url ：String : 异步加载时，设置url地址。需要返回的是一个json数组。 json数组相关节点的属性如下：12345678910[ &#123; text : String // 文本 hasChildren : boolean // 是否有子菜单 children ：json[] // 子菜单信息 expanded : boolean // 是否展开 classes : String // 样式们 class="aa bb cc " id ：String // 唯一标识 &#125; ] 在项目中导入相关的文件 下载文件，treeview开源地址：https://github.com/jzaefferer/jquery-treeview 将treeview导入项目[app]/js/,其中： jquery-1.8.3.js treeview依赖jquery库 images文件夹 插件相关的图标文件 screen.css 屏幕显示相关css jquery.treeview.css 核心css jquery.treeview.min.js 核心js jquery.treeview.async.js 支持异步 jquery.cookie.js 支持缓存 页面的实现新建一个menu.jsp文件，用于菜单结构的异步加载显示1234567891011121314151617181920&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="js/treeview/jquery.treeview.css" /&gt; &lt;link rel="stylesheet" href="js/treeview/screen.css" /&gt; &lt;script src="js/jquery-1.8.3.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.cookie.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.treeview.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.treeview.async.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="black" class="filetree"&gt;&lt;/ul&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; $("#black").treeview(&#123; url : "menu_showMenu.action" &#125;) &lt;/script&gt;&lt;/html&gt; web层实现在MenuAction类中添加showMenu()方法，用于菜单显示数据的处理12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 显示菜单public class MenuAction extends ActionSupport &#123; // Spring注入业务层接口 private MenuEbi menuEbi; public void setMenuEbi(MenuEbi menuEbi) &#123; this.menuEbi = menuEbi; &#125; public void showMenu() throws IOException &#123; //中文乱码解决 response.setContentType("text/html;charset=utf-8"); PrintWriter pw = response.getWriter(); // 1.首先获取root参数 String root = ServletActionContext.getRequest().getParameter("root"); // 2.判断参数值 source id HttpServletResponse response = ServletActionContext.getResponse(); //从session中获取当前登录用户 EmpModel loginEm = (EmpModel) ServletActionContext.getRequest().getSession().getAttribute("loginEm"); StringBuilder json = new StringBuilder(); json.append("["); if ("source".equals(root)) &#123; // 生成一级菜单 //获取当前登录用户可操作的一级菜单 List&lt;MenuModel&gt; menuList = menuEbi.getAllOneLevelByEmp(loginEm.getUuid()); for (MenuModel temp : menuList) &#123; json.append("&#123;\"text\":\""); json.append(temp.getName()); json.append("\",\"hasChildren\":true,\"classes\":\"folder\",\"id\":\""); json.append(temp.getUuid()); json.append("\"&#125;,"); &#125; &#125; else &#123; // 生成二级菜单项 // 获取指定一级菜单的二级菜单项 Long puuid = new Long(root); List&lt;MenuModel&gt; menuList = menuEbi.getByEmpAndPuuid(loginEm.getUuid(), puuid); for (MenuModel temp : menuList) &#123; json.append("&#123;\"text\":\"&lt;a class='hei' target='main' href='"); json.append(temp.getUrl()); json.append("'&gt;"); json.append(temp.getName()); json.append("&lt;/a&gt;\",\"hasChildren\":false,\"classes\":\"file\"&#125;,"); &#125; &#125; //删除最后一个','号 json.deleteCharAt(json.length() - 1); json.append("]"); pw.write(json.toString()); pw.flush(); &#125;&#125; 业务层实现 业务层接口 12345678910111213141516171819//开启事务@Transactionalpublic interface MenuEbi &#123; /** * 获取指定员工可操作的一级菜单 * * @param uuid 员工uuid * @return */ public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid); /** * 获取指定员工对应的指定一级菜单可操作的二级菜单 * @param uuid 员工uuid * @param puuid 一级菜单uuid * @return */ public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid);&#125; 业务层实现类 123456789public class MenuEbo implements MenuEbi &#123; public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid) &#123; return menuDao.getAllOneLevelByEmp(uuid); &#125; public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid) &#123; return menuDao.getByEmpAndPuuid(uuid, puuid); &#125;&#125; 持久层实现 持久层接口 12345public interface MenuDao &#123; public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid); public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid);&#125; 持久层实现类 123456789101112131415161718public class MenuImpl extends HibernateDaoSupport implements MenuDao &#123; /** * 获取系统菜单的子菜单 */ public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid) &#123; // menu-&gt;role-&gt;emp String hql = "select distinct menu from MenuModel menu join menu.roles role join role.emps emp where emp.uuid = ? and menu.parent.uuid = ? order by menu.uuid"; return this.getHibernateTemplate().find(hql, uuid, MenuModel.MENU_SYSTEM_MENU_UUID); &#125; /** * 获取指定菜单的子菜单 */ public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid) &#123; String hql = "select distinct menu from MenuModel menu join menu.roles role join role.emps emp where emp.uuid = ? and menu.parent.uuid = ? order by menu.uuid"; return this.getHibernateTemplate().find(hql, uuid, puuid); &#125;&#125; 页面显示 在主页面main.jsp中相应位置引入 menu.jsp 123&lt;div class="left-bottom"&gt; &lt;%@include file="/WEB-INF/jsps/tools/menu.jsp"%&gt; &lt;/div&gt; 最终效果： 总结 利用 jQuery treeview 实现树状效果十分方便,本次使用了它的异步加载实现了菜单功能,而其他的实现也是类似的,熟悉之后也能轻松的使用. ☆-end-☆]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
        <tag>jquery</tag>
        <tag>treeview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat JNDI数据源配置和使用]]></title>
    <url>%2F2017%2F03%2F15%2Ftomcat-datasource%2F</url>
    <content type="text"><![CDATA[进行实际业务开发时，如果使用的不是专用的应用服务器与数据库服务器，那么往往是在网络上租用一个虚拟的服务器空间，将WEB应用的war包放入服务器空间内，将数据库相关信息放入指定的数据库服务器空间内。 当应用启动时，会根据使用需要创建对应的数据库连接对象。但是如果该服务器上WEB应用过多时，每个WEB应用都有自己的数据库连接管理方式。而WEB服务器连接的数据库地址又唯一。此时如果数据库服务器进行迁移，会造成大多数WEB应用无法正常工作。 比较合理的解决方案是将Tomcat服务器与数据库服务器的连接关系进行统一配置，所有的应用都使用该配置，这样就不会造成数据库服务器迁移导致应用无法正常工作的现象。如果用户连接的是专用数据库服务器，即便上述操作修改，也不会产生影响。 Tomcat数据源 是一种将数据库的连接配置信息在服务器端（客户端独立配置）进行配置，当服务器启动时，创建该对象。用户只需要根据对应的名称进行获取就可以了。 配置Tomcat数据源 修改tomcat安装目录/conf/context.xml，添加如下配置 123456789101112&lt;Resource name="jdbc/DataSource" auth="Container" type="javax.sql.DataSource"maxActive="100" maxIdle="30" maxWait="10000"url="jdbc:mysql://localhost:3306/[app]"driverClassName="com.mysql.jdbc.Driver"username="root" password="123456" /&gt; 配置Web应用使用Tomcat数据源 修改WEB-INF/web.xml，添加如下配置 12345&lt;resource-ref&gt;&lt;res-ref-name&gt;jdbc/DataSource&lt;/res-ref-name&gt;&lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;&lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt; 配置Spring核心配置文件中使用数据源 开启jee命名空间 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns:jee="http://www.springframework.org/schema/jee"xsi:schemaLocation=" http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd "&gt;&lt;/beans&gt; 使用jee命名空间 123&lt;!-- 通过获取服务器配置的数据源，获取数据库连接的信息 --&gt;&lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/DataSource"/&gt; 重启服务器，测试功能。测试通过，可以正常登陆 [知识总结] 有关数据源对象的配置方式有很多种，此处仅为其中一种开发方式，而且此方式没有强依赖关系（其他配置方式中存在）。 JNDI ：(Java Naming and Directory Interface)Java命名和目录接口，是SUN公司提供的一种标准的Java命名系统接口,一个应用程序设计的API，它为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。JNDI名是远端访问的通用名称，可以理解为使用该名称获取对应的资源信息。JNDI的命名官方规范=&gt; java:comp/env/JNDI名称Jboss=&gt; java:JNDI名称Weblogic=&gt; JNDI名称 [开发技巧] 数据源在配置时，如果是绑定项目的，需要将数据库驱动jar包拷贝到tomcat的lib包下，否则服务器加载时无法找到驱动包，抛出异常 JNDI规范是J2EE标准定义，但是不同服务器厂商的定义规则有所不同，使用时需要进行区分对待 在进行测试功能的执行时，由于SessionFactory仍然需要加载，而此时服务器无需启动，造成DataSource对应的Bean无法加载，抛出异常。推荐开发阶段使用原始的DataSource，上线后修改为服务器数据源。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>datasouce</tag>
        <tag>JNDI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java使用视图值显示数据]]></title>
    <url>%2F2017%2F03%2F11%2Fjava-view-data%2F</url>
    <content type="text"><![CDATA[java视图值的使用开发中,数据库字段如：日期Long,性别int 在页面的显示问题。 视图值: 视图值是一种用于界面显示的变量值,该值不具体对应某个数据库字段,它服务与某个数据库字段。 当数据库中的某个字段值不便于显示时，为该字段添加视图值，用于显示对应的信息。 在Model中定义一个String类型的变量,变量名是无法合理显示的字段名+View 为其提供get方法 在其对应变量的set方法中对这个View值进行初始化 日期类型视图值123456789101112131415161718192021222324252627private Long birthday; //出生日期public String birthdayView; //为字段birthday添加视图值public String getBirthdayView() &#123; return birthdayView;&#125;//在相应字段的set方法中初始化视图值public void setBirthday(Long birthday) &#123; this.birthday = birthday; this.birthdayView = FormatUtil.formatDate(birthday);&#125;//日期通用格式化工具类 class FormatUtil &#123; public static final String formatDate(Long time)&#123; DateFormat df=new SimpleDateFormat("yyyy-MM-dd"); return df.format(new Date(time)); &#125; public static final String formatTime(Long time)&#123; DateFormat df=new SimpleDateFormat("HH:mm:ss"); return df.format(new Date(time)); &#125; public static final String formatDateTime(Long time)&#123; DateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return df.format(new Date(time)); &#125; &#125; 性别类型的视图值1234567891011private Integer gender; //性别:1-男;0-女public String genderView; //性别字段视图值public String getGenderView() &#123; return genderView;&#125;public void setGender(Integer gender) &#123; this.gender = gender; this.genderView = gender == 1 ? "男" : "女";&#125; 在页面上通过 OGNL 或 EL 表达式取值 1234&lt;s:iterator value="empList"&gt; &lt;s:property value="birthdayView"/&gt; &lt;td&gt;$&#123;genderView&#125;&lt;/td&gt;&lt;/s:iterator&gt; 如果相应的取值太多,可以采用如下方式: 123456789101112//数据结构思想应用public static final Integer EMP_GENDER_OF_MAN = 1;public static final Integer EMP_GENDER_OF_WOMAN = 0;public static final String EMP_GENDER_OF_MAN_VIEW = "男";public static final String EMP_GENDER_OF_WOMAN_VIEW = "女";public static final Map&lt;Integer, String&gt; genderMap = new HashMap&lt;Integer, String&gt;();static&#123;genderMap.put(EMP_GENDER_OF_MAN, EMP_GENDER_OF_MAN_VIEW);genderMap.put(EMP_GENDER_OF_WOMAN, EMP_GENDER_OF_WOMAN_VIEW);&#125; 相应的初始化 123456public void setGender(Integer gender) &#123; this.gender = gender; this.genderView = genderMap.get(gender);&#125; ``` 同时，在页面标签中可以通过如下方式动态的调用回显:(需要设置genderMap 为public) ``` 现在开发中更为普遍的是使用数据字典来解决此类问题.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>viewdata</tag>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F03%2F09%2Fhello-hexo%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start 1$ hexo new "My New Post" More info: Writing Run server1$ hexo server Run server1$ hexo server Run server1$ hexo server Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment ☆end☆]]></content>
  </entry>
</search>