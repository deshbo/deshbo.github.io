<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[jQuery + ajax+ json + Struts2 实现表单联动]]></title>
      <url>%2F2017%2F03%2F18%2Fform-linkage%2F</url>
      <content type="text"><![CDATA[在进行信息添加的过程中，经常会用到上下联动的需求，如省市联动。商品的供应商和商品类别的联动。如何实现呢？ 预加载数据进入商品信息添加页面前，需要加载一些需要的数据 首先要加载所有的供应商信息集合与第一个供应商对应的商品类别集合，并进行展示; 当供应商信息发生变化时，ajax动态加载商品类别信息，并进行展示。 如果供应商的商品类别为空时，直接不加载1234567891011121314151617181920public GoodsModel gm = new GoodsModel();// 到添加public String input() &#123; // 加载所有具有类别信息的供应商信息 List&lt;SupplierModel&gt; supplierList = supplierEbi.getAllUnion(); ActionContext.getContext().getSession().put("supplierList", supplierList); // 加载当前选中的供应商对应的所有商品类别信息 Long supplierUuid = null; if (gm.getUuid() != null) &#123; // 修改操作 gm = goodsEbi.get(gm.getUuid()); supplierUuid = gm.getGtm().getSm().getUuid(); &#125; else &#123; //不是修改操作，默认加载第一个 supplierUuid = supplierList.get(0).getUuid(); &#125; List&lt;GoodsTypeModel&gt; gtmList = goodsTypeEbi.getAllBySupUuid(supplierUuid); ActionContext.getContext().getSession().put("gtmList", gtmList); return "input";&#125; 页面请求 为供应商select添加选项改变事件 123456$(function()&#123; //为id为supplier 绑定change事件 $("#supplier").change(function()&#123; &#125;);&#125;); 添加测试语句，测试功能是否正常，例如添加alert语句 在操作中发送ajax请求，获取后台数据 123$.post("goodsType_ajaxGetBySupUuid.action",&#123;"gm.sm.uuid":supplierUuid&#125;,function(data)&#123;&#125;); 其中的参数说明: 第一次参数：发送的请求url 第二个参数：json格式的参数列表 第三个参数：当前ajax异步请求执行完毕后返回的处理事件，其中data参数封装了后台请求传输的数据 后台处理数据 在产品类别GoodsTypeAction中添加对应的方法，根据传递供应商编号获取对应类别信息 12345678private List&lt;GoodsTypeModel&gt; gtmList;//ajax获取供应商对应的类别信息public String ajaxGetBySupUuid()&#123; //根据供应商的uuid获取对应的类别信息 gtmList = goodsTypeEbi.getAllBySm(gm.getSm().getUuid()); return "ajaxGetBySupUuid"; &#125; 如何将数据传递出去得到的数据需要转化为json格式,可以使用json工具类JSONArray 加入struts-json-plugin.jar 此处使用struts-json插件完成该功能(√) =&gt;向项目中加入struts-json对应的jar包 提供get方法 该插件只能将Action类中的get开头的方法数据返回，因此为上述方法对应的数据提供get方法 123public List&lt;GoodsTypeModel&gt; getGtmList() &#123; return gtmList;&#125; 配置struts.xml struts.xml文件中开启json数据格式支持，修改默认的继承模式 &lt;package name=&quot;default&quot; namespace=&quot;/&quot; extends=&quot;json-default&quot;&gt; 设置对应的结果返回类型为json数据格式类型 type=&quot;json&quot; 12345&lt;!-- GoodsType --&gt;&lt;action name="goodsType_*" class="goodsTypeAction" method="&#123;1&#125;"&gt; &lt;result name="ajaxGetBySupUuid" type="json"&gt; &lt;/result&gt;&lt;/action&gt; 设置数据来源设置返回json数据，并没有指定返回的数据来源，需要指定返回数据来源,有几种常见方式 设置数据来源于action类中:&lt;param name=&quot;root&quot;&gt;action&lt;/param&gt;如果只设置数据来源于action类中，那么此时返回的数据将是Action类中所有的get方法开头的方法返回值，一般需要过滤。 包含过滤设置: &lt;param name=&quot;includeProperties&quot;&gt;gtmList\[\d\]\.uuid,gtmList\[\d\]\.name&lt;/param&gt; 排除过滤设置: &lt;param name=&quot;excludeProperties&quot;&gt; gtmList\[\d\]\.sm, &lt;/param&gt; 设置数据来源从某个根获取: (√) 1234567&lt;result&gt; &lt;param name="root"&gt;action&lt;/param&gt; &lt;param name="includeProperties"&gt; gtmList\[\d\]\.uuid, gtmList\[\d\]\.name &lt;/param&gt; &lt;/result&gt; PS: 设置root时，还可以设置对象或者集合对象。如果是对象，则获取的数据为对象json格式转化;如果是集合对象，则获取的数据为集合中的对象数组.上述格式中设置了需要的数据位gtmList集合中每个元素的uuid属性与gtmList集合中每个元素的name属性。 页面获取json数据 请求相应的回调方法的参数data中封装了上述返回的json格式数据,根据json数据的格式特点，获取其中的gtmList数据 将获取的数据拼装成jquery格式的option组件，并添加到对应的select中 由于每次都向类别select中添加数据，数据越来越多，应该每次先清除掉原始数据，然后添加。 12345678910111213var supplierUuid = $(this).val();$.post("goodsType_ajaxGetBySupUuid.action",&#123;"gm.sm.uuid":supplierUuid&#125;,function(data)&#123; //清除当前select中的项 $("#goodsType").empty(); var gtmList=data.gtmList; for(var i = 0 ; i&lt;gtmList.length;i++)&#123; var gtm=gtmList[i]; //将获取的数据组织成select中的option选项,然后添加到select中 $op=$("&lt;option value='"+gtm.uuid+"'&gt;"+gtm.name+"&lt;/option&gt;"); //将选项添加到select中 $("#goodsType").append($op); &#125;&#125;); 效果展示 知识总结 jquery发送ajax请求的方式 struts-json-plugin插件的使用方式 收集数据时，产品数据只需收集其类别数据即可，无需收集对应的供应商编号，毕竟后台数据模型关系式产品与产品类别产生关系。 其他如省市联动等也可以用类似的实现方式，使用起来也是非常方便的。 ☆end★]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Sublime Text3 OmniMarkupPreviewer 404]]></title>
      <url>%2F2017%2F03%2F18%2FOmniMarkupPreviewer-404%2F</url>
      <content type="text"><![CDATA[什么是 Markdown Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。 OmniMarkupPreviewer : 作为 Sublime Text 的一款强大插件，支持将标记语言渲染为 HTML 并在浏览器上实时预览，同时支持导出 HTML 源码文件。 第一次使用时报了如下的错误 Browser123456Sorry, the requested URL &apos;http://127.0.0.1:51004/view/61&apos; caused an error:&apos;buffer_id(61) is not valid (closed or unsupported file format)&apos;**NOTE:** If you run multiple instances of Sublime Text, you may want to adjustthe `server_port` option in order to get this plugin work again. SublimeText console log1234567891011121314151617181920212223242526272829303132333435SyntaxError: unexpected EOF while parsingOmniMarkupPreviewer: [INFO] Launching web browser for http://localhost:51004/view/42OmniMarkupPreviewer: [ERROR] Exception occured while rendering using MarkdownRenderer Traceback (most recent call last): File &quot;~\Sublime Text 3\Packages\OmniMarkupPreviewer\OmniMarkupLib\RendererManager.py&quot;, line 266, in render_text rendered_text = renderer.render(text, filename=filename) File &quot;~\Sublime Text 3\Packages\OmniMarkupPreviewer\OmniMarkupLib\Renderers/MarkdownRenderer.py&quot;, line 48, in render extensions=self.extensions) File &quot;~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py&quot;, line 493, in markdown md = Markdown(*args, **kwargs) File &quot;~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py&quot;, line 159, in __init__ configs=kwargs.get(&apos;extension_configs&apos;, &#123;&#125;)) File &quot;~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py&quot;, line 185, in registerExtensions ext = self.build_extension(ext, configs.get(ext, &#123;&#125;)) File &quot;~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\__init__.py&quot;, line 291, in build_extension return module.makeExtension(**configs) File &quot;~\Sublime Text 3\Packages\OmniMarkupPreviewer\OmniMarkupLib\Renderers\libs\mdx_strikeout.py&quot;, line 17, in makeExtension return StrikeoutExtension(configs=configs) File &quot;~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\extensions\__init__.py&quot;, line 51, in __init__ self.setConfigs(kwargs) File &quot;~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\extensions\__init__.py&quot;, line 82, in setConfigs self.setConfig(key, value) File &quot;~\SUBLIM~1\Packages\PYTHON~1\st3\markdown\extensions\__init__.py&quot;, line 70, in setConfig if isinstance(self.config[key][0], bool): KeyError: &apos;configs&apos; 解决方案错误原因是默认扩展中的strikeout不能正常加载。 Sublime Text &gt; Preferences &gt; Package Settings &gt; OmniMarkupPreviewer &gt; Settings - User12345&#123; "renderer_options-MarkdownRenderer": &#123; "extensions": ["tables", "fenced_code", "codehilite"] &#125;&#125; 设置保存后就可以正常使用了. 结束语这虽然是一个小问题，但是由于还不熟悉Python，花了一些时间折腾，但OmniMarkupPreviewer+ MarkdownEditing插件的结合，让Sublime Text3 中进行markdown语法的使用十分的方便,特此记录下来. [–end–]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery树状结构 jQuery Treeview 的使用]]></title>
      <url>%2F2017%2F03%2F17%2FjQuery-treeview-plugin%2F</url>
      <content type="text"><![CDATA[在项目中，我们经常会需要一些树状结构的样式来显示层级结构，菜单等，利用Jquery的一些插件，可以实现这些效果的，如Jquery.treeview。jquery treeview树控件是一款非常实用的jquery插件。 参数说明 参数说明参看 jQuery treeview 插件参数说明 其中 url ：String : 异步加载时，设置url地址。需要返回的是一个json数组。 json数组相关节点的属性如下：12345678910[ &#123; text : String 文本 hasChildren : boolean 是否有紫菜单 children ：json[] 子菜单信息 expanded : boolean 是否展开 classes : String 样式们 class=&quot;aa bb cc &quot; id ：String 唯一标识 &#125; ] 在项目中导入相关的文件 下载文件，treeview开源地址：https://github.com/jzaefferer/jquery-treeview 将treeview导入项目[app]/js/,其中： jquery-1.8.3.js treeview依赖jquery库 images文件夹 插件相关的图标文件 screen.css 屏幕显示相关css jquery.treeview.css 核心css jquery.treeview.min.js 核心js jquery.treeview.async.js 支持异步 jquery.cookie.js 支持缓存 页面的实现新建一个menu.jsp文件，用于菜单结构的异步加载显示1234567891011121314151617181920&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="js/treeview/jquery.treeview.css" /&gt; &lt;link rel="stylesheet" href="js/treeview/screen.css" /&gt; &lt;script src="js/jquery-1.8.3.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.cookie.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.treeview.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.treeview.async.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="black" class="filetree"&gt;&lt;/ul&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; $("#black").treeview(&#123; url : "menu_showMenu.action" &#125;) &lt;/script&gt;&lt;/html&gt; web层实现在MenuAction类中添加showMenu()方法，用于菜单显示数据的处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 显示菜单public class MenuAction extends ActionSupport &#123; // Spring注入业务层接口 private MenuEbi menuEbi; public void setMenuEbi(MenuEbi menuEbi) &#123; this.menuEbi = menuEbi; &#125; public void showMenu() throws IOException &#123; //中文乱码解决 response.setContentType("text/html;charset=utf-8"); PrintWriter pw = response.getWriter(); // 1.首先获取root参数 String root = ServletActionContext.getRequest().getParameter("root"); // 2.判断参数值 source id HttpServletResponse response = ServletActionContext.getResponse(); //从session中获取当前登录用户 EmpModel loginEm = (EmpModel) ServletActionContext.getRequest().getSession().getAttribute("loginEm"); StringBuilder json = new StringBuilder(); json.append("["); if ("source".equals(root)) &#123; // 生成一级菜单 //获取当前登录用户可操作的一级菜单 List&lt;MenuModel&gt; menuList = menuEbi.getAllOneLevelByEmp(loginEm.getUuid()); for (MenuModel temp : menuList) &#123; json.append("&#123;\"text\":\""); json.append(temp.getName()); json.append("\",\"hasChildren\":true,\"classes\":\"folder\",\"id\":\""); json.append(temp.getUuid()); json.append("\"&#125;,"); &#125; &#125; else &#123; // 生成二级菜单项 // 获取指定一级菜单的二级菜单项 Long puuid = new Long(root); List&lt;MenuModel&gt; menuList = menuEbi.getByEmpAndPuuid(loginEm.getUuid(), puuid); for (MenuModel temp : menuList) &#123; json.append("&#123;\"text\":\"&lt;a class='hei' target='main' href='"); json.append(temp.getUrl()); json.append("'&gt;"); json.append(temp.getName()); json.append("&lt;/a&gt;\",\"hasChildren\":false,\"classes\":\"file\"&#125;,"); &#125; &#125; //删除最后一个','号 json.deleteCharAt(json.length() - 1); json.append("]"); pw.write(json.toString()); pw.flush(); &#125;&#125; 业务层实现 业务层接口 12345678910111213141516171819//开启事务@Transactionalpublic interface MenuEbi &#123; /** * 获取指定员工可操作的一级菜单 * * @param uuid 员工uuid * @return */ public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid); /** * 获取指定员工对应的指定一级菜单可操作的二级菜单 * @param uuid 员工uuid * @param puuid 一级菜单uuid * @return */ public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid);&#125; 业务层实现类 123456789public class MenuEbo implements MenuEbi &#123; public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid) &#123; return menuDao.getAllOneLevelByEmp(uuid); &#125; public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid) &#123; return menuDao.getByEmpAndPuuid(uuid, puuid); &#125;&#125; 持久层实现 持久层接口 12345public interface MenuDao &#123; public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid); public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid);&#125; 持久层实现类 123456789101112131415161718public class MenuImpl extends HibernateDaoSupport implements MenuDao &#123; /** * 获取系统菜单的子菜单 */ public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid) &#123; // menu-&gt;role-&gt;emp String hql = "select distinct menu from MenuModel menu join menu.roles role join role.emps emp where emp.uuid = ? and menu.parent.uuid = ? order by menu.uuid"; return this.getHibernateTemplate().find(hql, uuid, MenuModel.MENU_SYSTEM_MENU_UUID); &#125; /** * 获取指定菜单的子菜单 */ public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid) &#123; String hql = "select distinct menu from MenuModel menu join menu.roles role join role.emps emp where emp.uuid = ? and menu.parent.uuid = ? order by menu.uuid"; return this.getHibernateTemplate().find(hql, uuid, puuid); &#125;&#125; 页面显示 在主页面main.jsp中相应位置引入 menu.jsp 123&lt;div class="left-bottom"&gt; &lt;%@include file="/WEB-INF/jsps/tools/menu.jsp"%&gt; &lt;/div&gt; 最终效果： 总结 利用 jQuery treeview 实现树状效果十分方便,本次使用了它的异步加载实现了菜单功能,而其他的实现也是类似的,熟悉之后也能轻松的使用. ☆-end-☆]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tomcat JNDI数据源配置和使用]]></title>
      <url>%2F2017%2F03%2F15%2Ftomcat-datasource%2F</url>
      <content type="text"><![CDATA[进行实际业务开发时，如果使用的不是专用的应用服务器与数据库服务器，那么往往是在网络上租用一个虚拟的服务器空间，将WEB应用的war包放入服务器空间内，将数据库相关信息放入指定的数据库服务器空间内。 当应用启动时，会根据使用需要创建对应的数据库连接对象。但是如果该服务器上WEB应用过多时，每个WEB应用都有自己的数据库连接管理方式。而WEB服务器连接的数据库地址又唯一。此时如果数据库服务器进行迁移，会造成大多数WEB应用无法正常工作。 比较合理的解决方案是将Tomcat服务器与数据库服务器的连接关系进行统一配置，所有的应用都使用该配置，这样就不会造成数据库服务器迁移导致应用无法正常工作的现象。如果用户连接的是专用数据库服务器，即便上述操作修改，也不会产生影响。 Tomcat数据源 是一种将数据库的连接配置信息在服务器端（客户端独立配置）进行配置，当服务器启动时，创建该对象。用户只需要根据对应的名称进行获取就可以了。 配置Tomcat数据源 修改tomcat安装目录/conf/context.xml，添加如下配置 123456789101112&lt;Resource name="jdbc/DataSource" auth="Container" type="javax.sql.DataSource"maxActive="100" maxIdle="30" maxWait="10000"url="jdbc:mysql://localhost:3306/[app]"driverClassName="com.mysql.jdbc.Driver"username="root" password="123456" /&gt; 配置Web应用使用Tomcat数据源 修改WEB-INF/web.xml，添加如下配置 12345&lt;resource-ref&gt;&lt;res-ref-name&gt;jdbc/DataSource&lt;/res-ref-name&gt;&lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;&lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt; 配置Spring核心配置文件中使用数据源, 开启jee命名空间 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns:jee="http://www.springframework.org/schema/jee"xsi:schemaLocation=" http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd "&gt;&lt;/beans&gt; 使用jee命名空间 123&lt;!-- 通过获取服务器配置的数据源，获取数据库连接的信息 --&gt;&lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/DataSource"/&gt; 重启服务器，测试功能。测试通过，可以正常登陆 [知识总结] 有关数据源对象的配置方式有很多种，此处仅为其中一种开发方式，而且此方式没有强依赖关系（其他配置方式中存在）。 JNDI ：(Java Naming and Directory Interface)Java命名和目录接口，是SUN公司提供的一种标准的Java命名系统接口,一个应用程序设计的API，它为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。JNDI名是远端访问的通用名称，可以理解为使用该名称获取对应的资源信息。JNDI的命名官方规范=&gt; java:comp/env/JNDI名称Jboss=&gt; java:JNDI名称Weblogic=&gt; JNDI名称 [开发技巧] 数据源在配置时，如果是绑定项目的，需要将数据库驱动jar包拷贝到tomcat的lib包下，否则服务器加载时无法找到驱动包，抛出异常 JNDI规范是J2EE标准定义，但是不同服务器厂商的定义规则有所不同，使用时需要进行区分对待 在进行测试功能的执行时，由于SessionFactory仍然需要加载，而此时服务器无需启动，造成DataSource对应的Bean无法加载，抛出异常。推荐开发阶段使用原始的DataSource，上线后修改为服务器数据源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java使用视图值显示数据]]></title>
      <url>%2F2017%2F03%2F11%2Fjava-view-data%2F</url>
      <content type="text"><![CDATA[java视图值的使用开发中,数据库字段如：日期Long,性别int 在页面的显示问题。视图值: 视图值是一种用于界面显示的变量值,该值不具体对应某个数据库字段,它服务与某个数据库字段。 当数据库中的某个字段值不便于显示时，为该字段添加视图值，用于显示对应的信息。 在Model中定义一个String类型的变量,变量名是无法合理显示的字段名+View 为其提供get方法 在其对应变量的set方法中对这个View值进行初始化 日期类型视图值123456789101112131415161718192021222324252627private Long birthday; //出生日期public String birthdayView; //为字段birthday添加视图值public String getBirthdayView() &#123; return birthdayView;&#125;//在相应字段的set方法中初始化视图值public void setBirthday(Long birthday) &#123; this.birthday = birthday; this.birthdayView = FormatUtil.formatDate(birthday);&#125;//日期通用格式化工具类 class FormatUtil &#123; public static final String formatDate(Long time)&#123; DateFormat df=new SimpleDateFormat("yyyy-MM-dd"); return df.format(new Date(time)); &#125; public static final String formatTime(Long time)&#123; DateFormat df=new SimpleDateFormat("HH:mm:ss"); return df.format(new Date(time)); &#125; public static final String formatDateTime(Long time)&#123; DateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return df.format(new Date(time)); &#125; &#125; 性别类型的视图值1234567891011private Integer gender; //性别:1-男;0-女public String genderView; //性别字段视图值public String getGenderView() &#123; return genderView;&#125;public void setGender(Integer gender) &#123; this.gender = gender; this.genderView = gender == 1 ? "男" : "女";&#125; 在页面上通过 OGNL 或 EL 表达式取值 1234&lt;s:iterator value="empList"&gt; &lt;s:property value="birthdayView"/&gt; &lt;td&gt;$&#123;genderView&#125;&lt;/td&gt;&lt;/s:iterator&gt; 如果相应的取值太多,可以采用如下方式: 123456789101112//数据结构思想应用public static final Integer EMP_GENDER_OF_MAN = 1;public static final Integer EMP_GENDER_OF_WOMAN = 0;public static final String EMP_GENDER_OF_MAN_VIEW = "男";public static final String EMP_GENDER_OF_WOMAN_VIEW = "女";public static final Map&lt;Integer, String&gt; genderMap = new HashMap&lt;Integer, String&gt;();static&#123;genderMap.put(EMP_GENDER_OF_MAN, EMP_GENDER_OF_MAN_VIEW);genderMap.put(EMP_GENDER_OF_WOMAN, EMP_GENDER_OF_WOMAN_VIEW);&#125; 相应的初始化 public void setGender(Integer gender) { this.gender = gender; this.genderView = genderMap.get(gender); } 同时，在页面标签中可以通过如下方式动态的调用回显:(需要设置genderMap 为public) &lt;s:select list=&quot;@me.erp.auth.emp.vo.EmpModel@genderMap&quot; name=&quot;em.gender&quot;/&gt; 现在开发中更为普遍的是使用数据字典来解决此类问题.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
