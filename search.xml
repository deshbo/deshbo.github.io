<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JQuery树状结构 jQuery-treeview 的使用]]></title>
      <url>%2F2017%2F03%2F17%2FjQuery-treeview-plugin%2F</url>
      <content type="text"><![CDATA[在项目中，我们经常会需要一些树状结构的样式来显示层级结构，菜单等，利用Jquery的一些插件，可以实现这些效果的，如Jquery.treeview。jquery treeview树控件是一款非常实用的jquery插件treeview。 参数说明: 参数说明参看 jQuery treeview 插件参数说明 其中url ：String : 异步加载时，设置url地址。需要返回的是一个json数组。 json数组相关节点的属性如下：12345678910[ &#123; text : String 文本 hasChildren : boolean 是否有紫菜单 children ：json[] 子菜单信息 expanded : boolean 是否展开 classes : String 样式们 class=&quot;aa bb cc &quot; id ：String 唯一标识 &#125; ] 在项目中导入相关的文件 下载文件，treeview开源地址：https://github.com/jzaefferer/jquery-treeview 将treeview所依赖的文件和图片导入项目[app]/js/,包括： jquery-1.8.3.js 放在[app]/js/下,treeview依赖jquery库 images文件夹 插件相关的图标文件 screen.css 屏幕显示相关css jquery.treeview.css 核心css jquery.treeview.min.js 核心js jquery.treeview.async.js 支持异步js jquery.cookie.js 支持缓存js 页面的实现新建一个menu.jsp文件，用于菜单结构的异步加载显示1234567891011121314151617181920&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;html&gt; &lt;head&gt; &lt;link rel="stylesheet" href="js/treeview/jquery.treeview.css" /&gt; &lt;link rel="stylesheet" href="js/treeview/screen.css" /&gt; &lt;script src="js/jquery-1.8.3.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.cookie.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.treeview.min.js" type="text/javascript"&gt;&lt;/script&gt; &lt;script src="js/treeview/jquery.treeview.async.js" type="text/javascript"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id="black" class="filetree"&gt;&lt;/ul&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; $("#black").treeview(&#123; url : "menu_showMenu.action" &#125;) &lt;/script&gt;&lt;/html&gt; web层实现在MenuAction类中添加showMenu()方法，用于菜单显示数据的处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 显示菜单public class MenuAction extends ActionSupport &#123; // 注入业务层接口 private MenuEbi menuEbi; public void setMenuEbi(MenuEbi menuEbi) &#123; this.menuEbi = menuEbi; &#125; public void showMenu() throws IOException &#123; //中文乱码解决 response.setContentType("text/html;charset=utf-8"); PrintWriter pw = response.getWriter(); // 1.首先获取root参数 String root = ServletActionContext.getRequest().getParameter("root"); // 2.判断参数值 source id HttpServletResponse response = ServletActionContext.getResponse(); //从session中获取当前登录用户 EmpModel loginEm = (EmpModel) ServletActionContext.getRequest().getSession().getAttribute("loginEm"); StringBuilder json = new StringBuilder(); json.append("["); if ("source".equals(root)) &#123; // 生成一级菜单 List&lt;MenuModel&gt; menuList = menuEbi.getAllOneLevelByEmp(loginEm.getUuid()); for (MenuModel temp : menuList) &#123; json.append("&#123;\"text\":\""); json.append(temp.getName()); json.append("\",\"hasChildren\":true,\"classes\":\"folder\",\"id\":\""); json.append(temp.getUuid()); json.append("\"&#125;,"); &#125; &#125; else &#123; // 生成二级菜单项 // 获取指定一级菜单的二级菜单项 Long puuid = new Long(root); List&lt;MenuModel&gt; menuList = menuEbi.getByEmpAndPuuid(loginEm.getUuid(), puuid); for (MenuModel temp : menuList) &#123; json.append("&#123;\"text\":\"&lt;a class='hei' target='main' href='"); json.append(temp.getUrl()); json.append("'&gt;"); json.append(temp.getName()); json.append("&lt;/a&gt;\",\"hasChildren\":false,\"classes\":\"file\"&#125;,"); &#125; &#125; //删除最后一个','号 json.deleteCharAt(json.length() - 1); json.append("]"); pw.write(json.toString()); pw.flush(); &#125;&#125; 业务层实现 业务层接口 12345678910111213141516171819//开启事务@Transactionalpublic interface MenuEbi &#123; /** * 获取指定员工可操作的一级菜单 * * @param uuid 员工uuid * @return */ public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid); /** * 获取指定员工对应的指定一级菜单可操作的二级菜单 * @param uuid 员工uuid * @param puuid 一级菜单uuid * @return */ public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid);&#125; 业务层实现 123456789public class MenuEbo implements MenuEbi &#123; public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid) &#123; return menuDao.getAllOneLevelByEmp(uuid); &#125; public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid) &#123; return menuDao.getByEmpAndPuuid(uuid, puuid); &#125;&#125; 持久层实现 持久层接口 12345public interface MenuDao &#123; public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid); public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid);&#125; 持久层实现 123456789101112131415161718public class MenuImpl extends HibernateDaoSupport implements MenuDao &#123; /** * 获取系统菜单的子菜单 */ public List&lt;MenuModel&gt; getAllOneLevelByEmp(Long uuid) &#123; // menu-&gt;role-&gt;emp String hql = "select distinct menu from MenuModel menu join menu.roles role join role.emps emp where emp.uuid = ? and menu.parent.uuid = ? order by menu.uuid"; return this.getHibernateTemplate().find(hql, uuid, MenuModel.MENU_SYSTEM_MENU_UUID); &#125; /** * 获取指定菜单的子菜单 */ public List&lt;MenuModel&gt; getByEmpAndPuuid(Long uuid, Long puuid) &#123; String hql = "select distinct menu from MenuModel menu join menu.roles role join role.emps emp where emp.uuid = ? and menu.parent.uuid = ? order by menu.uuid"; return this.getHibernateTemplate().find(hql, uuid, puuid); &#125;&#125; 页面显示 在需要显示页面对应的位置引入 menu.jsp 文件即可 123&lt;div class="left-bottom"&gt; &lt;%@include file="/WEB-INF/jsps/tools/menu.jsp"%&gt; &lt;/div&gt; 最终效果： [–end–]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Tomcat 数据源配置和使用]]></title>
      <url>%2F2017%2F03%2F15%2Ftomcat-datasource%2F</url>
      <content type="text"><![CDATA[进行实际业务开发时，如果使用的不是专用的应用服务器与数据库服务器，那么往往是在网络上租用一个虚拟的服务器空间，将WEB应用的war包放入服务器空间内，将数据库相关信息放入指定的数据库服务器空间内。 当应用启动时，会根据使用需要创建对应的数据库连接对象。但是如果该服务器上WEB应用过多时，每个WEB应用都有自己的数据库连接管理方式。而WEB服务器连接的数据库地址又唯一。此时如果数据库服务器进行迁移，会造成大多数WEB应用无法正常工作。 比较合理的解决方案是将Tomcat服务器与数据库服务器的连接关系进行统一配置，所有的应用都使用该配置，这样就不会造成数据库服务器迁移导致应用无法正常工作的现象。如果用户连接的是专用数据库服务器，即便上述操作修改，也不会产生影响。 Tomcat数据源 是一种将数据库的连接配置信息在服务器端（客户端独立配置）进行配置，当服务器启动时，创建该对象。用户只需要根据对应的名称进行获取就可以了。 配置Tomcat数据源 修改tomcat安装目录/conf/context.xml，添加如下配置 123456789101112&lt;Resource name="jdbc/DataSource" auth="Container" type="javax.sql.DataSource"maxActive="100" maxIdle="30" maxWait="10000"url="jdbc:mysql://localhost:3306/[app]"driverClassName="com.mysql.jdbc.Driver"username="root" password="123456" /&gt; 配置Web应用使用Tomcat数据源 修改WEB-INF/web.xml，添加如下配置 12345&lt;resource-ref&gt;&lt;res-ref-name&gt;jdbc/DataSource&lt;/res-ref-name&gt;&lt;res-type&gt;javax.sql.DataSource&lt;/res-type&gt;&lt;res-auth&gt;Container&lt;/res-auth&gt;&lt;/resource-ref&gt; 配置Spring核心配置文件中使用数据源, 开启jee命名空间 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beansxmlns:jee="http://www.springframework.org/schema/jee"xsi:schemaLocation=" http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.2.xsd "&gt;&lt;/beans&gt; 使用jee命名空间 123&lt;!-- 通过获取服务器配置的数据源，获取数据库连接的信息 --&gt;&lt;jee:jndi-lookup id="dataSource" jndi-name="java:comp/env/jdbc/DataSource"/&gt; 重启服务器，测试功能。测试通过，可以正常登陆 [知识总结] 有关数据源对象的配置方式有很多种，此处仅为其中一种开发方式，而且此方式没有强依赖关系（其他配置方式中存在）。 JNDI ：(Java Naming and Directory Interface)Java命名和目录接口，是SUN公司提供的一种标准的Java命名系统接口,一个应用程序设计的API，它为开发人员提供了查找和访问各种命名和目录服务的通用、统一的接口，类似JDBC都是构建在抽象层上。JNDI名是远端访问的通用名称，可以理解为使用该名称获取对应的资源信息。JNDI的命名官方规范=&gt; java:comp/env/JNDI名称Jboss=&gt; java:JNDI名称Weblogic=&gt; JNDI名称 [开发技巧] 数据源在配置时，如果是绑定项目的，需要将数据库驱动jar包拷贝到tomcat的lib包下，否则服务器加载时无法找到驱动包，抛出异常 JNDI规范是J2EE标准定义，但是不同服务器厂商的定义规则有所不同，使用时需要进行区分对待 在进行测试功能的执行时，由于SessionFactory仍然需要加载，而此时服务器无需启动，造成DataSource对应的Bean无法加载，抛出异常。推荐开发阶段使用原始的DataSource，上线后修改为服务器数据源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[java使用视图值显示数据]]></title>
      <url>%2F2017%2F03%2F11%2Fjava-view-data%2F</url>
      <content type="text"><![CDATA[java视图值的使用开发中,数据库字段如：日期Long,性别int 在页面的显示问题。视图值: 视图值是一种用于界面显示的变量值,该值不具体对应某个数据库字段,它服务与某个数据库字段。 当数据库中的某个字段值不便于显示时，为该字段添加视图值，用于显示对应的信息。 在Model中定义一个String类型的变量,变量名是无法合理显示的字段名+View 为其提供get方法 在其对应变量的set方法中对这个View值进行初始化 日期类型视图值123456789101112131415161718192021222324252627private Long birthday; //出生日期public String birthdayView; //为字段birthday添加视图值public String getBirthdayView() &#123; return birthdayView;&#125;//在相应字段的set方法中初始化视图值public void setBirthday(Long birthday) &#123; this.birthday = birthday; this.birthdayView = FormatUtil.formatDate(birthday);&#125;//日期通用格式化工具类 class FormatUtil &#123; public static final String formatDate(Long time)&#123; DateFormat df=new SimpleDateFormat("yyyy-MM-dd"); return df.format(new Date(time)); &#125; public static final String formatTime(Long time)&#123; DateFormat df=new SimpleDateFormat("HH:mm:ss"); return df.format(new Date(time)); &#125; public static final String formatDateTime(Long time)&#123; DateFormat df=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); return df.format(new Date(time)); &#125; &#125; 性别类型的视图值1234567891011private Integer gender; //性别:1-男;0-女public String genderView; //性别字段视图值public String getGenderView() &#123; return genderView;&#125;public void setGender(Integer gender) &#123; this.gender = gender; this.genderView = gender == 1 ? "男" : "女";&#125; 在页面上通过 OGNL 或 EL 表达式取值 1234&lt;s:iterator value="empList"&gt; &lt;s:property value="birthdayView"/&gt; &lt;td&gt;$&#123;genderView&#125;&lt;/td&gt;&lt;/s:iterator&gt; 如果相应的取值太多,可以采用如下方式: 123456789101112//数据结构思想应用public static final Integer EMP_GENDER_OF_MAN = 1;public static final Integer EMP_GENDER_OF_WOMAN = 0;public static final String EMP_GENDER_OF_MAN_VIEW = "男";public static final String EMP_GENDER_OF_WOMAN_VIEW = "女";public static final Map&lt;Integer, String&gt; genderMap = new HashMap&lt;Integer, String&gt;();static&#123;genderMap.put(EMP_GENDER_OF_MAN, EMP_GENDER_OF_MAN_VIEW);genderMap.put(EMP_GENDER_OF_WOMAN, EMP_GENDER_OF_WOMAN_VIEW);&#125; 相应的初始化 public void setGender(Integer gender) { this.gender = gender; this.genderView = genderMap.get(gender); } 同时，在页面标签中可以通过如下方式动态的调用回显:(需要设置genderMap 为public) &lt;s:select list=&quot;@me.erp.auth.emp.vo.EmpModel@genderMap&quot; name=&quot;em.gender&quot;/&gt; 现在开发中更为普遍的是使用数据字典来解决此类问题.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F09%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
